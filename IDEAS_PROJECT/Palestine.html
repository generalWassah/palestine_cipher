<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Palestine Cipher</title>
  <link rel="stylesheet" href="styles/cipherPalestineStyle.css">
  <!-- MathJax -->
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\', '\']],
        tags: "ams",
      }
    };
  </script>
  <script async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>

  <!-- Header Section -->
  <header>
    <h1>Palestine Guard</h1>
    <nav>
      <ul>
        <li><a href="#program-description">Program Description</a></li>
        <li><a href="#cipher-enhanced">Palestine Ciphers</a></li>
        <li><a href="#analysis-metric">Cryptanalysis</a></li>
        <li><a href="#key-generator">Key Generator</a></li>
        <li><a href="#about">About</a></li>
      </ul>
    </nav>
  </header>

  <!-- Main Container -->
  <main>
    <section class="container" id="encrypt-section">
      <div id="cipher_select_cont">
        <label for="select_cipher" id="choose_cipher">Cipher:</label>
        <select id="select_cipher">
          <option value="alpha">Alpha</option>
          <option value="beta">Beta</option>
          <option value="gamma">Gamma</option>
          <option value="classical_Vigenere">Vigenère</option>
        </select>
      </div>
      <div id="cipher_container">
        <h1 id="cipher_type">Palestine Cipher: Gamma</h1>
      </div>
      <h2>Encrypt / Decrypt</h2>
      <div id="cipherEncDecCon">
        <div id="func_implement_container" class='func_implement_container'>

          <div class='functions_container'>
            <div>
              <input id='diffusion_option' class="small_input_and_select" type='checkbox' checked="true"> <span
                class='my-dif-imp-label'>Diffusion:</span>
            </div>
            <div>
              <select id="mySelectFunc" class="select" name="newsfunctions">
                <option value="north">North</option>
                <option value="north_odd">NorthOdd</option>
                <option value="south">South</option>
                <option value="south_odd">SouthOdd</option>
                <option value="east">East</option>
                <option value="east_odd">EastOdd</option>
                <option value="west">West</option>
                <option value="west_odd">WestOdd</option>

              </select>
            </div>
          </div><!-- functions_container -->

          <div class="implementations_container">
            <div>
              <input id='implementation_option' class="small_input_and_select" type='checkbox'> <span
                class='my-dif-imp-label'>Implementation (Modes):</span>
            </div>
            <div>
              <select id="mySelectImplement" class="select" name="newsImplementations">
                <option value="outward">OutWard</option>
                <option value="inward">InWard</option>
                <option value="rightward">RightWard</option>
                <option value="rightwardReversed">RightWardReversed</option>
                <option value="leftward">LeftWard</option>
                <option value="leftwardReversed">LeftWardReversed</option>
              </select>
            </div>
          </div><!-- implementation -->

        </div><!-- func_implement_container -->
        <div>
          <div class="label-n-encDec">
            <div> <label class='my-label' for="input">Input:</label></div>
            <div class="enc-dec-options">
              <div><input id="encRadio" type="radio" name="encDecRadio" checked="true" /><label
                  class="my-label">Encryption</label></div>
              <div><input id="decRadio" type="radio" name="encDecRadio" /><label class="my-label">Decryption</label>
              </div>
            </div>
          </div>
          <textarea class="main-boxes" id="input" rows="5" placeholder="Enter plaintext"></textarea>
          <div>
            <span id="lettersLen"></span>
            <span id="digitsLen"></span>
          </div>
        </div>
        <div id="diff-orbit-inputs" class="diff-orbit-inputs">

          <div class="indexes">
            <div id="_PILcontainer">
              <label for='_PalestineIndexL' class='my-label'>PIL:</label>
              <input id="_PalestineIndexL" class='orbit-Pal' type="number" min="0" value="0" />
            </div>
            <div id="_OILcontainer">
              <label for='orbitIndexL' class='my-label'>OIL:</label>
              <input id='orbitIndexL' class='orbit-Pal' type="number" min="1" value="1" />
            </div>
          </div>

          <div class="indexes">
            <div id="_PIDcontainer">
              <label for='_PalestineIndexD' class='my-label'>PID:</label>
              <input id="_PalestineIndexD" class='orbit-Pal' type="number" min="0" value="0" />
            </div>
            <div id="_OIDcontainer">
              <label for='orbitIndexD' class='my-label'>OID:</label>
              <input id='orbitIndexD' class='orbit-Pal' type="number" min="1" value="1" />
            </div>
          </div>
        </div>
        <div>
          <div id="keyLabel_n_diffuserCont">
            <label id="keyLabel" class="my-label" for="key">Key:</label>
            <div>
              <label class="my-label" for="key-diffuser-option">Function:</label>
              <select id="key-diffuser-option">
                <option value="northKey">North</option>
                <option value="eastKey">East</option>
                <option value="westKey">West</option>
                <option value="southKey">South</option>
              </select>
            </div>
          </div>
          <input class="main-boxes" type="text" id="key" placeholder="Enter Vigenère key">
        </div>

        <div class="buttons">
          <a href="#outputLabel"><button id="btnEnc" onclick="encryptText()">Encrypt</button></a>
          <a href="#outputLabel"><button id="btnDec" onclick="decryptText()">Decrypt</button></a>
        </div>
        <div id='genKey'>
          <button id='show_cipher_key' onclick='showGeneratedKey()'>View Palestine key</button>
          <a href="#encrypt-section"><button id="reset" onclick="reseter()">reset</button></a>
        </div>
        <div>
          <div class="label-n-format">
            <div id="outputLabel"> <label class="my-label" for="output">Output:</label></div>
            <div class="format"><input id='format' type="checkbox" /><label class='my-label'>format output </label>
            </div>
          </div>
          <textarea class="main-boxes" id="output" placeholder="Ciphertext appears here ..." readonly></textarea>
        </div>
        <button id="copy-output" class="copy-buttons" onclick="copyTextOutput()" disabled>copy</button>
      </div> <!--CipherEncDecContainer-->
    </section>

    <section class="container" id="key-print">
      <h2>Print Effective Key</h2>
      <button id="printKeyBTN" onclick="getEffectiveKey()">Print Palestine Key</button>
      <textarea class="main-boxes" id="keyprint" placeholder="The Palestine key used for encryption appears here ..."
        readonly></textarea>
      <button id="copy-enc-key" class="copy-buttons" onclick="copyTextEncKey()" disabled>copy</button>
    </section>

    <section class="container" id="key-generator">
      <h2>Key Generator</h2>
      <input id="genVigKeyInput" type="text" placeholder="Enter Vigenère Key">
      <input id="keyLenL" type="number" min="1" placeholder="Length Letters">
      <input id="keyLenD" type="number" min="1" placeholder="Length Digits">
      <button onclick="generatePalestineKey()">Generate Palestine Key</button>
      <button onclick="clearGenField()">clear</button>
      <textarea id="keyPalestineOutput" class="main-boxes" placeholder="The expanded or Palestine key appears here ..."
        readonly></textarea>
      <button id="copy-gen-key" class="copy-buttons" onclick="copyTextGenKey()" disabled>copy</button>
    </section>

    <section class="container" id="cipher-enhanced">
      <h2>Palestine Ciphers Encryption</h2>
      <div>
        <p>
          We propose three enhancements to the Vigenère cipher, namely <strong>Alpha</strong>, <strong>Beta</strong>,
          and
          <strong>Gamma</strong>. These enhancements are collectively referred to as the <em>Palestine Ciphers</em>.
          Each enhancement is briefly described below.
        </p>

        <p>
          <br>
          Let:
          <br><br>
          $P$ = plaintext <br>
          $G$ = diffused plaintext <br>
          $C$ = ciphertext <br>
          $K$ = Vigenère key <br>
          $B$ = Palestine key <br>
          $Diff$ = diffusion algorithm <br>
          $Gen$ = key generator <br>
          $Enc$ = encryption algorithm <br>
          $Dec$ = decryption algorithm <br>
        </p>

        <h3>Vigenère Cipher</h3>
        <p>
          Before introducing our enhancements, let’s first review the classical Vigenère cipher. It is a polyalphabetic
          substitution cipher based on a repeating keyword. However, due to the periodic nature of the key and lack of
          diffusion, the cipher is vulnerable to statistical attacks.
        </p>


        <strong>Encryption:</strong>
        <div class="math-block">
          \[
          C = Enc(P, K),
          \]
          \[
          \text{where} \quad c_i = (p_i + k_i) \mod 26
          \]
        </div>
        <strong>Decryption:</strong>
        <div class="math-block">
          \[
          P = Dec(C, K),
          \]
          \[ \text{where} \quad p_i = (c_i - k_i) \mod 26
          \]
        </div>
        Encryption of digits uses modulo 10.


        <h3>Palestine Cipher: Alpha Enhancement</h3>
        <p>
          In the Alpha enhancement, the Vigenère key is passed into a generator to produce a non-periodic <em>Palestine
            key</em> $B$ of the same length as the plaintext. The plaintext is then encrypted using this key.
          <br><br>
          Unlike the classical Vigenère cipher, this method does not apply diffusion to the plaintext. It is similar to
          the Vernam cipher, except that the key is pseudo-random and reusable.
        </p>

        <strong>Encryption:</strong>
        <div class="math-block">
          \[
          B = Gen(K),
          \]

          \[ C = Enc(P, B),
          \]
          \[
          \text{where} \quad c_i = (p_i + b_i) \mod 26
          \]
        </div>
        <strong>Decryption:</strong>
        <div class="math-block">
          \[
          B = Gen(K),
          \]
          \[
          P = Dec(C, B),
          \]
          \[
          \text{where} \quad p_i = (c_i - b_i) \mod 26
          \]
        </div>
        Encryption of digits uses modulo 10.


        <h3>Palestine Cipher: Beta Enhancement</h3>
        <p>
          In the Beta enhancement, the plaintext is first transformed using a diffusion algorithm to produce $G$. This
          diffused plaintext is then encrypted using the original Vigenère key.
        </p>

        <strong>Encryption:</strong>
        <div class="math-block">
          \[
          G = Diff(P),
          \]
          \[
          C = Enc(G, K),
          \]
          \[
          \text{where} \quad c_i = (g_i + k_i) \mod 26
          \]
        </div>
        <strong>Decryption:</strong>
        <div class="math-block">
          \[
          G = Dec(C, K),
          \]
          \[
          \text{where} \quad g_i = (c_i - k_i) \mod 26,
          \]
          \[
          P = Diff^{-1}(G)
          \]
        </div>
        Diffusion and digit encryption use modulo 10.


        <h3>Palestine Cipher: Gamma Enhancement</h3>
        <p>
          The Gamma enhancement combines both Alpha and Beta. The Vigenère key is transformed into a non-periodic
          Palestine key $B$ of length equal to the plaintext. Simultaneously, the plaintext undergoes diffusion to form
          $G$. Finally, the ciphertext is obtained by encrypting $G$ with $B$.
        </p>

        <strong>Encryption:</strong>
        <div class="math-block">
          \[
          B = Gen(K), \quad G = Diff(P),
          \]
          \[ C = Enc(G, B),
          \]
          \[
          \text{where} \quad c_i = (g_i + b_i) \mod 26
          \]
        </div>
        <strong>Decryption:</strong>
        <div class="math-block">
          \[
          G = Dec(C, B),
          \]
          \[
          \text{where} \quad g_i = (c_i - b_i) \mod 26,
          \]
          \[
          P = Diff^{-1}(G)
          \]
        </div>
        Diffusion and digit encryption use modulo 10.

      </div>
    </section>
    <section class="container" id="program-description">
      <h2>Software Description</h2>
      <div>
        <p>
          This section describes the implemented features of the Palestine ciphers.
        </p>
        <h3>Diffusion</h3>
        <p>
          The diffusion checkbox is checked by default allowing the diffusion functions to be used. Four primary
          functions known as the NEWS functions and four inverse functions made for odd input lengths make up the
          diffusion functions.
          This includes the primary functions. <a
            href="https://thegoodnewsproject.w3spaces.com/diffusion/north_diffusion.html" target="_blank"> <strong>
              North</strong> <a />, <a href="https://thegoodnewsproject.w3spaces.com/diffusion/east_diffusion.html"
              target="_blank"> <strong>East</strong> </a>,
            <a href="https://thegoodnewsproject.w3spaces.com/diffusion/west_diffusion.html" target="_blank">
              <strong>West</strong> </a> and <a
              href="https://thegoodnewsproject.w3spaces.com/diffusion/south_diffusion.html" target="_blank">
              <strong>South</strong> </a> functions.
            Each of the NEWS functions represents an algorithm for finding
            non-trivial partial solution of homogeneous linear Diophantine equation (HLDE) in $n$ unknowns.
            The inverse of the NEWS functions depend on whether the input length is even or odd. For odd input lengths
            the inverse functions are the following
            <a href="https://thegoodnewsproject.w3spaces.com/diffusion/northOdd_diffusion.html"
              target="_blank"><strong>NorthOdd</strong></a>, <a
              href="https://thegoodnewsproject.w3spaces.com/diffusion/eastOdd_diffusion.html"
              target="_blank"><strong>EastOdd</strong></a>, <a
              href="https://thegoodnewsproject.w3spaces.com/diffusion/westOdd_diffusion.html"
              target="_blank"><strong>WestOdd</strong></a> and <a
              href="https://thegoodnewsproject.w3spaces.com/diffusion/southOdd_diffusion.html"
              target="_blank"><strong>SouthOdd</strong></a>.
        </p>

        <h3>Inverse functions</h3>
        <div>
          <table>
            <thead>
              <tr>
                <th>
                  S/N
                </th>
                <th>
                  Function
                </th>
                <th>
                  Inverse (Even)
                </th>
                <th>
                  Inverse (Odd)
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>North</td>
                <td>South</td>
                <td>NorthOdd</td>
              </tr>
              <tr>
                <td>2</td>
                <td>East</td>
                <td>West</td>
                <td>EastOdd</td>
              </tr>
              <tr>
                <td>3</td>
                <td>West</td>
                <td>East</td>
                <td>WestOdd</td>
              </tr>
              <tr>
                <td>4</td>
                <td>South</td>
                <td>North</td>
                <td>SouthOdd</td>
              </tr>

            </tbody>
          </table>
        </div>
        <p>
          For even input lengths, the inverse for the <a
            href="https://thegoodnewsproject.w3spaces.com/diffusion/north_diffusion.html"
            target="_blank"><strong>North</strong></a> function is equivalent to the <a
            href="https://thegoodnewsproject.w3spaces.com/diffusion/south_diffusion.html"
            target="_blank"><strong>South</strong></a> function and vice versa.
          Similarly the inverse of the <a href="https://thegoodnewsproject.w3spaces.com/diffusion/east_diffusion.html"
            target="_blank"><strong>East</strong></a> function
          is equivalent to the <a href="https://thegoodnewsproject.w3spaces.com/diffusion/west_diffusion.html"
            target="_blank"><strong>West</strong></a> function and vice versa. Because of this equivalence, there is no
          need to implement the inverse functions seperately for even input length.
          The NEWS functions or their inverse functions can be used as the diffusion functions.
        </p>
        <p>
          The diffusion functions and their inverses can be implemented in matrix as well as in compact form.
          The current implementation is based on the compact form.
        </p>

        <p>

          Assuming the <a href="https://thegoodnewsproject.w3spaces.com/diffusion/east_diffusion.html"
            target="_blank"><strong>East</strong></a> function is used as the diffusion function
          <br> <br>
          let
          <br> <br>
          $l=$ plaintext length
          <br> <br>
          if $l$ is even
          \[
          G = East(P,l)
          \]

          to recover $P$ we compute

          \[
          P = West(G,l)
          \]

          if $l$ is odd

          \[
          G^{'} = East(P,l)
          \]

          to recover $P$ we compute

          \[
          P = EastOdd(G^{'},l)
          \]
          $G$ and $G^{'}$ are the respective diffused text for the even and odd input length.
        </p>
      </div>

      <h3>Implementation (Modes)</h3>
      <p>
        By checking the implementation checkbox, the implementation functions gets loaded and ready to be used. The
        implementations consist of six functions namely; <strong>OutWard</strong>, <strong>InWard</strong>,
        <strong>RightWard</strong>, <strong>RightWardReversed</strong>, <strong>LeftWard</strong>, and
        <strong>LeftWardReversed</strong>. They achieve diffusion differently by calling on any
        of the eight diffusion functions in an iterative manner. The implementation functions are much more slower in
        execution as compared to the main diffusion functions due to there iterative nature.
        While the main diffusion functions fully diffuse the entire input in a single diffusion operation, the
        implementation functions operates on the input chunk by chunk until the entire
        input is diffused. The description of the implementation functions will be included at a later date.
      </p>
      <div>
        <table>
          <thead>
            <tr>
              <th>
                S/N
              </th>
              <th>
                Operation
              </th>
              <th>
                Reversed Operation
              </th>

            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td>OutWard</td>
              <td>InWard</td>
            </tr>
            <tr>
              <td>2</td>
              <td>RightWard</td>
              <td>RightWardReversed</td>
            </tr>
            <tr>
              <td>3</td>
              <td>LeftWard</td>
              <td>LeftWardReversed</td>
            </tr>

          </tbody>
        </table>
      </div>
      <p>
        Assuming we are using
        the <strong>OutWard</strong> implementation together with the <a
          href="https://thegoodnewsproject.w3spaces.com/diffusion/north_diffusion.html"
          target="_blank"><strong>North</strong></a> function as the diffusion function.
        The diffusion process is as follows
        <br> <br>
        if $l$ is even
        <br>
        \[
        G = OutWard(P,l,North)
        \]

        to recover $P$ we compute

        \[
        P = InWard(G,l,South)
        \]

        if $l$ is odd

        \[
        G^{'} = OutWard(P,l,North)
        \]

        to recover $P$ we compute

        \[
        P = InWard(G^{'},l,NorthOdd)
        \]
      </p>
      <h3>Encryption/Decryption Button</h3>
      <p>
        By selecting the encryption radio button, the cipher enters encryption
        mode. Similarly by selecting the decryption radio button, the cipher enters
        decryption mode. If encryption is performed and decryption is attempted
        within the same session, the program automatically loads the relevant inverse
        functions.
      </p>
      <h3>Input</h3>
      <p>
        This field is where users enter plaintext to encrypt or ciphertext to decrypt. The program only targets
        digits $[0-9]$ and English letters [A-Z].
        Users can enter either letters or digits or both. Diffusion and encryption of letters follows modulo $26$,
        while diffusion and encryption of digits follows modulo $10$.
        If plaintext contains both letters and digits, users
        should ensure that they are both even or both odd to ensure correct decryption. If the program
        prompt users to make letters and digits both even or both odd, they should just add a single letter or digit to
        the input.
        Note that uppercase letters and lowercase letters are
        treated the same with $A=a=0$, $B=b=1$, $C=c=2$, $\dots$, $Z=z=25$.
      </p>
      <h3>Key</h3>
      <p>
        This input field is where users enter the key which can either be letters or digits or both. The
        key should be of considerable length. If the input field consist of only letters then the key must only be
        in letters and if the input field consist of only digits then the key must only be in digits. If the input
        consist
        of both letters and digits the key must consist of letters and digits as well.
      </p>
      <h3>Palestine key</h3>
      <p>
        The Palestine key is a non-periodic key generated from the Vigenère key. It is generated by passing a given
        Vigenère key into the key expasion function.
        The length of the generated Palestine key matches the plaintext length. The Palestine key for a plaintext of
        length 20 is different from the Palestine key
        for plaintext of length 30 even though the Vigenère key used by the key generator is the same. This means that a
        Palestine key is only reused for plaintext of equal lengths.
        The <a href="https://www.dcode.fr/index-coincidence">index of coincidence</a> (IC) of Palestine key for large
        plaintext length is near 1/26 0r 0.03846 which suggests a random sequence.
      </p>
      <h3>Output</h3>
      <p>
        This is where the result of the encryption or decryption operation is displayed. Other non-English text or
        characters appearing in the input field are displayed along with the encrypted letters and
        digits in the order they appear in the input field.
      </p>
      <h3>OIL</h3>
      <p>
        This stands for Orbit Index for Letters. Here users can specify a value telling the program the number of
        iterations they want. Each iteration of the implemented compact form of the NEWS functions corresponds to matrix
        exponentiation if
        the matrix form of the NEWS functions is used.
        A value of $1$ returns the first orbit of the sequence and a value $4$ returns the $4^{th}$ orbit of the
        iterated sequence. The
        total number of orbits of the iterated sequence is finite with some input having as low as tens of orbits
        while some having as large as a thounsand orbits or tens of thousands of orbits or even millions of orbts.
        The number of orbits is influenced by the modulo and length of input.
        The OIL value affects the output of the Palestine key generator.
        Users are advised
        to use a number ranging from $1$ to $4$ for optimal performance and to avoid selecting a value beyond to input's
        maximum number of orbits.
        To experiment with plaintext orbits, users should visit the NEWS functions page.
      </p>
      <h3>OID</h3>
      <p>
        This stands for Orbit Index for Digits. This is similar to the Orbit Index for Letters (OIL) but applies to
        digits.
      </p>
      <h3>PIL</h3>
      <p>
        This stands for Palestine Index for Letters.
        It is a value that specify which index of the original output gets substituted just before the diffusion
        operation for specific input ends.
        This index corresponds to the row of the skew-symmetric matrix when the matrix implementation of diffusion
        function is used. This field only appears if the
        length of input letters is odd. If the implementation checkbox is checked the value of PIL should be $0$ if
        plaintext consist of single letter or $0,1,2$ for odd length
        plaintext greater than $1$. This is to ensure that the diffusion applied to plaintext using the implementation
        functions is reversible. Using just the diffusion functions without
        the implementation functions, the value of PIL ranges from $0$ through $n-1$ where $n$ is the plaintext length.
      </p>

      <h3>PID</h3>
      <p>
        This stands for Palestine Index for Digits. This is similar to the Palestine Index for Letters (PIL) but applies
        to digits. This field only appears if length of input
        digit is odd.
      </p>
      <h3>format output</h3>
      <p>
        If checked, the output is formatted in accordance with the input's format, otherwise spaces and line breaks are
        removed.
      </p>
      <h3>Print Effective Key</h3>
      <p>
        This section allow users to print the effective key used for the encryption/decryption operation by clicking on
        the associated button.
        This allow users to copy the effective key for the purpose of analysis. Note that the key that gets printed
        depend on wether
        the Vigenère cipher is being used or the Palestine cipher which is an enhanced version of the Vigenère cipher.
      </p>
      <h3>Key Generator</h3>
      <p>
        The key generator takes a Vigenère key as input, then generate non-periodic key called Palestine key. The
        Palestine key exhibit the <a href="https://en.m.wikipedia.org/wiki/Avalanche_effect" target="_blank">avalanche
          effect</a> such that if the Vigenère key is changed slightly, the output Palestine key is impacted
        significantly.
        It can be used for letters, digits or both. The output of the key generator is influenced by the OIL value for
        letters or OID value for digits.
      </p>
    </section>
    <section class="container" id="analysis-metric">

      <h2>Cryptanalysis of the Vigenère Cipher</h2>
      <p>
        This section reviews common cryptanalytic techniques and shows how the Vigenère cipher is vulnerable to
        them—followed by how the Palestine Cipher (Alpha, Beta, and Gamma) resists these attacks. You are encouraged to
        test these metrics using external tools to see the contrast in action.
      </p>

      <h3>Index of Coincidence</h3>
      <p>
        <a href="https://en.m.wikipedia.org/wiki/Index_of_coincidence" target="_blank">Index of Coincidence (IC)</a>
        measures the probability that two randomly selected letters in a text are identical. A high IC (~0.065) suggests
        structured text (like English); a low IC (~0.0385) suggests randomness.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> The Vigenère cipher, especially with short keys, exhibits IC values closer
            to English plaintext, revealing patterns that enable key length estimation and frequency analysis.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Alpha:</strong> Uses a non-periodic, pseudorandom key, lowering IC toward randomness.</li>
              <li><strong>Beta:</strong> Diffuses plaintext with matrix transformations, disrupting letter patterns even
                with periodic keys.</li>
              <li><strong>Gamma:</strong> Combines both methods, achieving IC values near 0.0385 (e.g., IC = 0.03845 for
                12,418-character ciphertext).</li>
            </ul>
            Test here: <a href="https://www.dcode.fr/index-coincidence" target="_blank">dCode IC calculator</a>
          </li>
        </ul>
      </div>
      <h3>Friedman Test</h3>
      <p>
        <a href="https://planetcalc.com/7956/" target="_blank">Friedman’s test</a> estimates key length using IC. It
        assumes the key is periodic.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> The Vigenère cipher’s repeating key causes periodic IC peaks that allow
            Friedman’s test to reliably approximate the key length.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Alpha & Gamma:</strong> Use non-repeating keys. As such, the estimated key length is either
                incorrect or infinite.</li>
              <li><strong>Beta:</strong> Even with a repeating key, matrix diffusion breaks the ciphertext's
                periodicity,
                confusing the test.</li>
            </ul>
            Test here: <a href="https://planetcalc.com/7956/" target="_blank">Friedman test</a>
          </li>
        </ul>
      </div>
      <h3>Kasiski Examination</h3>
      <p>
        <a href="https://en.m.wikipedia.org/wiki/Kasiski_examination" target="_blank">Kasiski examination</a> finds
        repeated patterns in ciphertext that correspond to repeated key usage.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> The Vigenère cipher with repeated keys creates recurring ciphertext
            segments
            when the same plaintext and key parts align—making key length discovery trivial.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Alpha & Gamma:</strong> The key never repeats, so no periodic ciphertext fragments appear.
              </li>
              <li><strong>Beta:</strong> The plaintext is diffused before encryption, destroying repeated segments even
                with periodic keys.</li>
            </ul>
            Try it: <a href="https://planetcalc.com/8550/" target="_blank">Kasiski Tool</a>
          </li>
        </ul>
      </div>
      <h3>Autocorrelation (Key Repetition Test)</h3>
      <p>
        <a href="https://legacy.cryptool.org/en/cto/autocorrelation" target="_blank">Autocorrelation</a> detects
        repeating keys by sliding the ciphertext over itself and comparing matching characters.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> The Vigenère cipher shows autocorrelation peaks at multiples of the key
            length due to periodic encryption.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Alpha & Gamma:</strong> Since the key is non-periodic, autocorrelation is flat—no peaks
                appear.
              </li>
              <li><strong>Beta:</strong> Matrix-based plaintext diffusion ensures even repeated keys don’t generate
                repeating ciphertext patterns.</li>
            </ul>
            Try autocorrelation: <a href="https://legacy.cryptool.org/en/cto/autocorrelation" target="_blank">Crypto
              Tool
              Online</a>
          </li>
        </ul>
      </div>
      <h3>Mutual Index of Coincidence (MIC)</h3>
      <p>
        MIC assumes periodicity and compares IC across multiple ciphertext columns, each encrypted with the same key
        letter.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> The Vigenère cipher’s periodic key allows the ciphertext to be split into
            parts, each cracked via frequency analysis.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Alpha & Gamma:</strong> Since no key character repeats in the same position, MIC-based
                splitting
                fails.</li>
              <li><strong>Beta:</strong> Even with repetition, the diffusion ensures different statistics across
                segments.
              </li>
            </ul>
            Explore: <a href="https://cryptii.com/pipes/frequency-analysis" target="_blank">Cryptii Frequency
              Analyzer</a>
          </li>
        </ul>
      </div>
      <h3>Chi-Squared Test</h3>
      <p>
        <a href="http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-statistic/"
          target="_blank">Chi-squared</a> tests how close the letter frequencies in ciphertext are to expected English
        frequencies.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> In Vigenère, when ciphertext is split by key length, each segment often
            retains frequency profiles similar to shifted English, making it easy to break.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Alpha:</strong> Pseudorandom key disrupts frequency profiles.</li>
              <li><strong>Beta & Gamma:</strong> Matrix diffusion destroys language-dependent structure—no English
                frequency remains.</li>
            </ul>
            Try it: <a
              href="http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-statistic/"
              target="_blank">Practicalcryptography.com</a>
          </li>
        </ul>
      </div>
      <h3>Entropy</h3>
      <p>
        <a href="https://planetcalc.com/2476/" target="_blank">Entropy</a> measures randomness in a text. Higher entropy
        suggests better security.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> Vigenère ciphertexts with short keys often have entropy in the 4.1–4.5
            range, revealing non-randomness.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Gamma:</strong> Our tests show entropy ≈ 4.88—comparable to random text.</li>
              <li><strong>Beta:</strong> Diffusion increases entropy even without key enhancements.</li>
              <li><strong>Alpha:</strong> Slight improvement due to pseudorandom key, though less than Beta or Gamma.
              </li>
            </ul>
            Test here: <a href="https://planetcalc.com/2476/" target="_blank">Entropy Calculator</a>
          </li>
        </ul>
      </div>
      <h3>Avalanche Effect</h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Avalanche_effect" target="_blank">Avalanche Effect</a> refers to the
        phenomenon where a small change in input causes large changes in output—important for resisting differential
        cryptanalysis.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> In Vigenère, changing a single letter in the plaintext affects only the
            corresponding ciphertext character—no avalanche effect.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Beta & Gamma:</strong> Diffusion ensures each input symbol affects nearly all output symbols.
              </li>
              <li><strong>Alpha:</strong> Less impact here since it lacks diffusion, though the non-periodic key
                slightly
                randomizes output.</li>
            </ul>
          </li>
        </ul>
      </div>
      <h3>Diffusion Test (No Encryption)</h3>
      <p>
        To isolate the diffusion effect, encrypt with a key of all "A"s (e.g., "AAAAAA"). Since "A" corresponds to 0, no
        Vigenère shift occurs—only diffusion remains.
      </p>
      <div>
        <ul>
          <li><strong>Vulnerability:</strong> Vigenère without a key does nothing; plaintext remains unchanged.</li>
          <li><strong>Palestine Cipher Defense:</strong>
            <ul>
              <li><strong>Beta & Gamma:</strong> Still produce transformed text due to standalone diffusion.</li>
            </ul>
            Try this with tools like: <a href="https://cryptii.com/pipes/caesar-cipher" target="_blank">Cryptii Caesar
              Cipher</a> (use shift = 0)
          </li>
        </ul>
      </div>
    </section>
  </main>

  <!-- Footer Section -->
  <footer class="site-footer">
    <div class="footer-content">
      <p>&copy; 2025 Palestine Guard. All rights reserved.</p>
      <p id="author">Author: Abdullahi Isah</p>
      <a href="tel:+2348032742729"><i class="fas fa-phone-alt"></i> +2348032742729</a>
      <a href="mailto:isahabdullahi50@gmail.com"><i class="fas fa-envelope"></i>isahabdullahi50@gmail.com</a>
    </div>
    <section id="about">
      <h2>About Palestine Guard</h2>
      <p>
        <strong>Palestine Guard</strong> is a dedicated platform for showcasing cryptographic innovations developed by
        Abdullahi Isah — a cybersecurity researcher and software developer. The site serves as a portfolio hub for
        secure encryption systems designed to protect data both at rest and in transit.
      </p>

      <p>
        Created during a time of great adversity for the people of Palestine, this project symbolizes solidarity and
        resilience. Its name reflects both a technical mission and a moral stance: to guard what matters, digitally and
        humanly.
      </p>

      <p>
        At the heart of Palestine Guard is the <strong>Palestine Cipher</strong>, a family of encryption algorithms
        built on rigorous mathematics. The cipher leverages partial solutions to homogeneous linear Diophantine
        equations, employing skew-symmetric transformations that enable whole-plaintext diffusion — eliminating the need
        for block processing. The result is a cipher with a strong avalanche effect, high resistance to statistical
        attacks, and ciphertext nearly indistinguishable from random noise.
      </p>

      <p>
        Innovations include a non-periodic pseudorandom key (Palestine Key) with low index of coincidence, optimized
        matrix-free diffusion algorithms (reducing complexity from O(n²) to O(n)), and reversible transformations even
        under odd-length input via x_0 substitution. Unlike traditional ciphers, the legitimate user works with
        compact mathematical forms, while an adversary would require a full matrix — increasing the barrier to
        cryptanalysis.
      </p>

      <p>
        Driven by values of <strong>privacy, flexibility, and cryptographic rigor</strong>, Palestine Guard aspires to
        develop encryption techniques resilient against both classical and quantum attacks. The project welcomes
        opportunities for collaboration, particularly with employers and researchers interested in pushing the
        boundaries of secure communication.
      </p>
    </section>
  </footer>

  <!-- Font Awesome CDN -->
  <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>

  <!-- Vigenére cipher script -->
  <script src="scripts/myVigenere/cipherVigenereScript.js"></script>
  <!-- Palestine cipher script -->
  <script src="scripts/myPalestine/myPalestine.js"></script>
  <!-- helper functions -->
  <!--<script src="scripts/helper_functions/helperFunctions.js"></script>-->
  <!-- NEWS diffusion functions scripts -->
  <script src="scripts/news_diffusion_functions/northDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/northOddDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/eastDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/eastOddDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/westDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/westOddDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/southDiffusion.js"></script>
  <script src="scripts/news_diffusion_functions/southOddDiffusion.js"></script>

  <script>
    document.getElementById("select_cipher").selectedIndex = 2;
    /* 
    alert("An implementation of the Alpha and Beta enhancement of the Vigenère cipher has" +
      " been added to the site. Users can now choose a cipher by selecting it in the Choose Cipher option");
   */
    // global variable initialization
    let _PalestineIndex = 0;
    let orbitIndex = 1;

    let formatState = false;

    let encryptedLetters = '';
    let encryptedDigits = '';

    let decryptedDigits = '';
    let undiffusedLetters = '';
    let undiffusedDigits = '';

    let encryptClick;
    let decryptClick;

    let implementationOption = document.getElementById('implementation_option');
    let diffusionOption = document.getElementById('diffusion_option');

    let input = document.getElementById("input").value.trim();
    let output = document.getElementById("output").value;
    let key = document.getElementById("key").value.trim();
    let letters = "";
    let digits = "";
    let lettersKey;
    let digitsKey;
    let lettersLen = 0;
    let digitsLen = 0;

    document.getElementById("btnDec").disabled = true;
    document.getElementById("printKeyBTN").disabled = true;
    document.getElementById("show_cipher_key").disabled = true;
    document.getElementById("_PILcontainer").style.visibility = "hidden";
    document.getElementById("_PIDcontainer").style.visibility = "hidden";
    //  let select_cipher = document.getElementById("select_cipher"); 
    // if(select_cipher.value==="alpha"||select_cipher.value==="classical_Vigenere"){
    hideIndexesL();
    hideIndexesD();
    // }
    let myKey = document.getElementById("key");
    myKey.addEventListener("change", () => {
      document.getElementById("output").value = "";
      if (myKey.value !== "") {
        if (containsLetter(myKey.value) || containsDigit(myKey.value)) {
          document.getElementById("show_cipher_key").disabled = false;
        } else {
          document.getElementById("show_cipher_key").disabled = true;
        }
      } else {
        document.getElementById("show_cipher_key").disabled = true;
      }

    });

    let encOption = document.getElementById("encRadio");

    encOption.addEventListener("click", function () {
      document.getElementById("input").placeholder = "Enter plaintext";
      document.getElementById("output").placeholder = "Ciphertext appears here ...";

      if (encOption.checked == true) {
        implementationOption.checked = false;
        document.getElementById("mySelectImplement").disabled = true;
        document.getElementById("mySelectImplement").selectedIndex = 0;
        document.getElementById("mySelectFunc").selectedIndex = 0;
        document.getElementById("btnEnc").disabled = false;
        document.getElementById("btnDec").disabled = true;
        let diffOptionState = document.getElementById('diffusion_option').checked;
        if (diffOptionState == true) {
          document.getElementById("keyprint").placeholder = "The Palestine key used for encryption appears here ...";
        } else {
          document.getElementById("keyprint").placeholder = "The Vigenère key used for encryption appears here ...";
        }
      }
    });

    let decOption = document.getElementById("decRadio");

    decOption.addEventListener("click", function () {

      document.getElementById("input").placeholder = "Enter ciphertext";
      document.getElementById("output").placeholder = "Plaintext appears here ...";

      if (decOption.checked == true) {
        decryptionSetup();
        let output = document.getElementById("output").value;
        if (output !== "") {
          document.getElementById("input").value = output;
          document.getElementById("output").value = "";

        }
        let diffOptionState = document.getElementById('diffusion_option').checked;
        if (diffOptionState == true) {
          document.getElementById("keyprint").placeholder = "The Palestine key used for decryption appears here ...";
        } else {
          document.getElementById("keyprint").placeholder = "The Vigenère key used for decryption appears here ...";
        }
        document.getElementById("btnEnc").disabled = true;
        document.getElementById("btnDec").disabled = false;
      }
    });

    let myFormat = document.getElementById('format');
    myFormat.addEventListener("click", function () {
      let input = document.getElementById('input').value;
      let key = document.getElementById('key').value;
      let formatChecked = myFormat.checked;
      if (input !== "" && key !== "") {
        if (formatChecked == false) {
          formatState = false;
          if (encryptClick == true) {
            if (diffusionOption.checked == true) {
              document.getElementById("output").value = format(encryptedLetters, encryptedDigits);
            } else {
              document.getElementById("output").value = format(encryptedLetters, encryptedDigits);
            }
          } else if (decryptClick == true) {
            if (diffusionOption.checked) {
              document.getElementById("output").value = format(undiffusedLetters, undiffusedDigits);
            } else {
              document.getElementById("output").value = format(decryptedLetters, decryptedDigits);
            }
          }
        } else {
          formatState = true;
          if (encryptClick == true) {
            if (diffusionOption.checked) {
              document.getElementById("output").value = format(encryptedLetters, encryptedDigits);
            } else {
              document.getElementById("output").value = format(encryptedLetters, encryptedDigits);
            }
          } else if (decryptClick == true) {
            if (diffusionOption.checked) {
              document.getElementById("output").value = format(undiffusedLetters, undiffusedDigits);
            } else {
              document.getElementById("output").value = format(decryptedLetters, decryptedDigits);
            }
          }
        }
      }
    });

    let inputChange = document.getElementById("input");
    inputChange.addEventListener("change", function () {
      document.getElementById("lettersLen").innerText = "Letters length = 0";
      document.getElementById("digitsLen").innerText = "Digits length = 0";
      input = inputChange.value;
      if (containsLetter(input)) {
        letters = getLetters(input);
      }

      if (containsDigit(input)) {
        digits = getDigits(input);
      }

      if (inputChange.value != "") {
        if (!containsLetter(input) && !containsDigit(input)) {
          alert("The text you provided does not contain letters [A-Z], [a-z] or digits [0-9]");
          return;
        }
      }
      document.getElementById("copy-output").disabled = false;

      lettersLen = letters.length;
      digitsLen = digits.length;

      let diff_orbit_inputs = document.getElementById("diff-orbit-inputs");

      let select_cipher = document.getElementById("select_cipher");
      let selected_cipher = select_cipher.value;

      hideIndexesL();
      hideIndexesD();

      let orbitIndexL = document.getElementById("orbitIndexL");

      let orbitIndexD = document.getElementById("orbitIndexD");

      if (containsLetter(input)) {

        // cipher check
        if (selected_cipher === "gamma" || selected_cipher === "beta") {
          showIndexesL();
          if (lettersLen % 2 == 1) {
            document.getElementById("_PILcontainer").style.visibility = "visible";
            let _PIL = document.getElementById('_PalestineIndexL');
            _PIL.value = 0;
            _PIL.max = lettersLen - 1;
          }

          if (lettersLen % 2 == 0 || lettersLen == 0) {
            document.getElementById("_PILcontainer").style.visibility = "hidden";
          }

          document.getElementById("_OILcontainer").style.visibility = "visible";
          orbitIndexL.value = 1;

        }    // selected cipher

      } else if (!containsLetter(input)) {
        hideIndexesL();
        lettersLen = 0;
      }// contains letter    

      if (containsDigit(input)) {


        if (selected_cipher === "gamma" || selected_cipher === "beta") {
          showIndexesD();
          if (digitsLen % 2 == 1) {
            document.getElementById("_PIDcontainer").style.visibility = "visible";
            let _PID = document.getElementById('_PalestineIndexD');
            _PID.value = 0;
            _PID.max = digitsLen - 1;
          }

          if (digitsLen % 2 == 0 || digitsLen == 0) {
            document.getElementById("_PIDcontainer").style.visibility = "hidden";
          }
          document.getElementById("_OIDcontainer").style.visibility = "visible";
          orbitIndexD.value = 1;

        }
      } else if (!containsDigit(input)) {
        hideIndexesD();
        digitsLen = 0;
      }// contains digit    

      if (!containsLetter(input) && !containsDigit(input)) {
        hideIndexesL();
        hideIndexesD();
      }

      document.getElementById("lettersLen").innerText = "Letters length = " + lettersLen + ",  ";
      document.getElementById("digitsLen").innerText = "Digits length = " + digitsLen;

      let outputVal = document.getElementById('output').value;
      if (outputVal != "") {
        document.getElementById('output').value = '';
      }
    });

    checkedImplementation = implementationOption.checked;
    let checkedNEWS = diffusionOption.checked;
    document.getElementById("mySelectImplement").disabled = true;
    //implementation checkbox click event    
    implementationOption.addEventListener('change', function () {
      let impchecked = implementationOption.checked;
      if (impchecked == false) {
        checkedImplementation = false;
        document.getElementById("mySelectImplement").selectedIndex = 0;
        document.getElementById("mySelectImplement").disabled = true;
      } else if (impchecked == true) {
        checkedImplementation = true;
        document.getElementById("mySelectImplement").disabled = false;
      }
    });// implementation option checkbox click event

    // diffusion option checkbox change event
    diffusionOption.addEventListener("change", function () {
      let inputVal = document.getElementById("input").value;
      if (inputVal === '') {
        document.getElementById("_PILcontainer").style.display = "none";
        document.getElementById("_PIDcontainer").style.display = "none";
      }
      document.getElementById("keyprint").value = "";
      let dchecked = diffusionOption.checked;
      if (dchecked === false) {
        checkedNEWS = false;
        document.getElementById("output").value = "";
        document.getElementById("diff-orbit-inputs").style.height = 0;
        document.getElementById("diff-orbit-inputs").style.visibility = 'hidden';
        document.getElementById("mySelectFunc").selectedIndex = 0;
        document.getElementById("mySelectFunc").disabled = true;
        document.getElementById("mySelectImplement").selectedIndex = 0;
        document.getElementById("mySelectImplement").disabled = true;
        document.getElementById('implementation_option').checked = false;
        document.getElementById('implementation_option').disabled = true;

        let select_cipher = document.getElementById("select_cipher");
        if (select_cipher.value == "classical_Vigenere") {
          document.getElementById('cipher_type').innerText = 'Vigenère Cipher';
          document.getElementById('printKeyBTN').innerText = 'Print Vigenère key';
          document.getElementById('show_cipher_key').textContent = 'View Vigenère key';
        } else if (select_cipher.value == "alpha") {
          document.getElementById('cipher_type').innerText = 'Palestine Cipher: Alpha';
          document.getElementById('printKeyBTN').innerText = 'Print Palestine key';
          document.getElementById('show_cipher_key').textContent = 'View Palestine key';
        }

        let encOptionState = document.getElementById("encRadio").checked;
        let decOptionState = document.getElementById("decRadio").checked;

        if (select_cipher.value === "alpha") {
          if (encOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Palestine key used for encryption appears here ...";
          } else if (decOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Palestine key used for decryption appears here ...";
          }
        }

        if (select_cipher.value === "classical_Vigenere") {
          if (encOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Vigenère key used for encryption appears here ...";
          } else if (decOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Vigenère key used for decryption appears here ...";
          }
        }
      } else if (dchecked === true) {
        checkedNEWS = true;

        if (lettersLen % 2 == 1 && lettersLen != 0) {
          document.getElementById("_PILcontainer").style.visibility = "visible";
        }

        if (digitsLen % 2 == 1 && digitsLen != 0) {
          document.getElementById("_PIDcontainer").style.visibility = "visible";
        }

        document.getElementById("output").value = "";
        document.getElementById("diff-orbit-inputs").style.height = 'auto';
        document.getElementById("diff-orbit-inputs").style.visibility = 'visible';

        document.getElementById("mySelectFunc").disabled = false;
        document.getElementById('implementation_option').disabled = false;

        let select_cipher = document.getElementById("select_cipher");
        if (select_cipher.value === "gamma") {
          document.getElementById('cipher_type').innerText = 'Palestine Cipher: Gamma';
          document.getElementById('printKeyBTN').innerText = 'Print Palestine key';
          document.getElementById('show_cipher_key').textContent = 'View Palestine key';
        } else if (select_cipher.value === "beta") {
          document.getElementById('cipher_type').innerText = 'Palestine Cipher: Beta';
          document.getElementById('printKeyBTN').innerText = 'Print Vigenère key';
          document.getElementById('show_cipher_key').textContent = 'View Vigenère key';
        }

        let encOptionState = document.getElementById("encRadio").checked;
        let decOptionState = document.getElementById("decRadio").checked;

        if (select_cipher.value == "beta") {
          if (encOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Vigenère key used for encryption appears here ...";
          } else if (decOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Vigenère key used for decryption appears here ...";
          }
        }

        if (select_cipher.value == "gamma") {
          if (encOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Palestine key used for encryption appears here ...";
          } else if (decOptionState === true) {
            document.getElementById("keyprint").placeholder = "The Palestine key used for decryption appears here ...";
          }
        }
      }

    });// diffusion option checkbox click event

    function copyTextOutput() {
      const text = document.getElementById("output").value;
      navigator.clipboard.writeText(text).then(() => {
        alert("Copied the text!");
      }).catch(err => {
        console.error("Failed to copy: ", err);
      });
    }
    function copyTextEncKey() {
      const text = document.getElementById("keyprint").value;
      navigator.clipboard.writeText(text).then(() => {
        alert("Copied the key!");
      }).catch(err => {
        console.error("Failed to copy: ", err);
      });
    }

    function copyTextGenKey() {
      const text = document.getElementById("keyPalestineOutput").value;
      navigator.clipboard.writeText(text).then(() => {
        alert("Copied the key!");
      }).catch(err => {
        console.error("Failed to copy: ", err);
      });
    }

    function canToggle() {
      if (select_cipher == "gamma" || select_cipher == "beta") {
        return false;
      }
    }

    // prevent diffusion checkbox toggle
    diffusionOption.addEventListener("click", function (e) {
      if (!canToggle()) {
        e.preventDefault();
        //diffusionOption.checked = !diffusionOption.checked;
      }
    });

    // Cipher selection
    let select_cipher = document.getElementById("select_cipher");
    select_cipher.addEventListener("change", () => {
      document.getElementById("encRadio").checked = true;
      let input_change = document.getElementById("input");
      let selected_cipher = select_cipher.value;

      if (selected_cipher === "alpha") {

        diffusionOption.checked = false;
        diffusionOption.dispatchEvent(new Event("change", { bubbles: true }));
        hideDiffusion();

        input_change.dispatchEvent(new Event("change", { bubbles: true }));

      } else if (selected_cipher === "beta") {

        diffusionOption.checked = true;
        diffusionOption.dispatchEvent(new Event("change", { bubbles: true }));
        implementationOption.checked = false;
        implementationOption.dispatchEvent(new Event("change", { bubbles: true }));
        showDiffusion();

        input_change.dispatchEvent(new Event("change", { bubbles: true }));

      } else if (selected_cipher === "gamma") {

        diffusionOption.checked = true;
        diffusionOption.dispatchEvent(new Event("change", { bubbles: true }));
        implementationOption.checked = false;
        implementationOption.dispatchEvent(new Event("change", { bubbles: true }));
        showDiffusion();

        input_change.dispatchEvent(new Event("change", { bubbles: true }));

      } else if (selected_cipher === "classical_Vigenere") {

        diffusionOption.checked = false;
        diffusionOption.dispatchEvent(new Event("change", { bubbles: true }));
        hideDiffusion();

        input_change.dispatchEvent(new Event("change", { bubbles: true }));

      }
    });


    let orbitIndexL = document.getElementById('orbitIndexL').value;
    let _PalestineIndexL = document.getElementById('_PalestineIndexL').value;
    let orbitIndexD = document.getElementById('orbitIndexD').value;
    let _PalestineIndexD = document.getElementById('_PalestineIndexD').value;

    function decryptionSetup() {
      let dchecked = document.getElementById('diffusion_option').checked;
      let impchecked = document.getElementById('implementation_option').checked;
      let encDiff = document.getElementById("mySelectFunc").selectedIndex;
      if (dchecked == true && encryptClick == true) {
        if (encDiff == 0) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 1;
          } else {
            document.getElementById("mySelectFunc").selectedIndex = 2;
          }
        } else if (encDiff == 1) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 0;
          }
        } else if (encDiff == 2) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 3;
          } else {
            document.getElementById("mySelectFunc").selectedIndex = 0;
          }
        } else if (encDiff == 3) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 2;
          }
        } else if (encDiff == 4) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 5;
          } else {
            document.getElementById("mySelectFunc").selectedIndex = 6;
          }
        } else if (encDiff == 5) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 4;
          }
        } else if (encDiff == 6) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 7;
          } else {
            document.getElementById("mySelectFunc").selectedIndex = 4;
          }
        } else if (encDiff == 7) {
          if (lettersLen % 2 == 1 || digitsLen % 2 == 1) {
            document.getElementById("mySelectFunc").selectedIndex = 6;
          }
        }
      }
      let encImp = document.getElementById("mySelectImplement").selectedIndex;
      if (impchecked == true && encryptClick == true) {
        if (encImp == 0) {
          document.getElementById("mySelectImplement").selectedIndex = 1;
        } else if (encImp == 1) {
          document.getElementById("mySelectImplement").selectedIndex = 0;
        } else if (encImp == 2) {
          document.getElementById("mySelectImplement").selectedIndex = 3;
        } else if (encImp == 3) {
          document.getElementById("mySelectImplement").selectedIndex = 2;
        } else if (encImp == 4) {
          document.getElementById("mySelectImplement").selectedIndex = 5;
        } else if (encImp == 5) {
          document.getElementById("mySelectImplement").selectedIndex = 4;
        }
      }

    } // decryptionSetup()

    // Encryption function
    function encryptText() {

      encryptClick = true;
      decryptClick = false;
      // Palestine Cipher Encryption using the NEWS functions and its implementations
      document.getElementById("keyprint").value = "";
      let dchecked = document.getElementById('diffusion_option').checked;
      let impchecked = document.getElementById('implementation_option').checked;
      let keyL = "";
      let keyD = "";
      input = document.getElementById("input").value.trim();
      key = document.getElementById("key").value.trim();
      if (containsLetter(key)) {
        keyL = getLetters(key).toUpperCase();
      }
      if (containsDigit(key)) {
        keyD = getDigits(key);
      }
      document.getElementById("key").value = keyL + keyD;

      if (!input || !key) {
        alert("Please enter both message and key.");
        return;
      }


      if (dchecked == true || impchecked == true) {
        // global variables

        if (containsLetter(input) || containsLetter(key)) {

          let lettersPln = '';
          let diffusedLetters = '';

          // plaintext letter and key match check
          if (containsLetter(input) === false && containsLetter(key)) {
            alert("Provide plaintext in letter(s) to encrypt with given key in letter(s) or remove the key in letter(s) to continue");
            return;
          }

          if (containsLetter(key) == false && containsLetter(input)) {
            alert("Provide key in letter(s) to encrypt plaintext in letter(s) or remove the plaintext in letter(s) to continue");
            return;
          }

          // plaintext digits and key match check
          if (containsDigit(input) === false && containsDigit(key)) {
            alert("Provide plaintext in digit(s) to encrypt with given key in digit(s) or remove the key in digit(s) to continue");
            return;
          }

          if (containsDigit(key) == false && containsDigit(input)) {
            alert("Provide key in digit(s) to encrypt plaintext in digit(s) or remove the plaintext in digit(s) to continue");
            return;
          }

          if (containsLetter(input)) {
            lettersPln = getLetters(input);
            lettersLen = lettersPln.length;
            diffusedLetters = getDiffusedMessage(lettersPln);
          }

          if ((lettersLen % 2 !== digitsLen % 2) && (lettersLen !== 0 && digitsLen !== 0)) {
            alert("Ensure that the length of plaintext letters and digits are both even or are both odd");
            return;
          }

          if (containsLetter(key)) {
            lettersKey = getLetters(key);
          }

          if (select_cipher.value === 'beta') {
            // Palestine Cipher Encryption: Beta Implementation 
            let myVigenereKeyL = getVigenereKey(lettersKey);
            let myBetaL = new Palestine(diffusedLetters, myVigenereKeyL);
            encryptedLetters = myBetaL.getEncryptedLetters();
          } else if (select_cipher.value === 'gamma') {
            // Palestine Cipher Encryption: Gamma Implementation      
            let myPalestineKeyL = getPalestineKey(lettersKey);
            let myGammaL = new Palestine(diffusedLetters, myPalestineKeyL);
            encryptedLetters = myGammaL.getEncryptedLetters();
          }

        } //containsLetter()

        if (containsDigit(input) || containsDigit(key)) {

          let digitsPln = '';
          let diffusedDigits = '';
          if (containsDigit(input)) {
            digitsPln = getDigits(input);
            digitsLen = digitsPln.length;
            diffusedDigits = getDiffusedMessage(digitsPln);

          }

          if ((lettersLen % 2 !== digitsLen % 2) && (lettersLen !== 0 && digitsLen !== 0)) {
            alert("Ensure that the length of plaintext letters and digits are both even or are both odd");
            return;
          }

          if (containsDigit(key)) {
            digitsKey = getDigits(key);
          }

          if (select_cipher.value === 'beta') {
            // Palestine Cipher Encryption: Beta Implementation 
            let myVigenereKeyD = getVigenereKey(digitsKey);
            let myBetaD = new Palestine(diffusedDigits, myVigenereKeyD);
            encryptedDigits = myBetaD.getEncryptedDigits();
          } else if (select_cipher.value === 'gamma') {
            // Palestine Cipher Encryption: Gamma Implementation      
            let myPalestineKeyD = getPalestineKey(digitsKey);
            let myGammaD = new Palestine(diffusedDigits, myPalestineKeyD);
            encryptedDigits = myGammaD.getEncryptedDigits();
          }

        } // containsDigit();


        document.getElementById("output").value = format(encryptedLetters, encryptedDigits);

      } else if (dchecked == false) {// Vigenère Cipher Encryption

        input = document.getElementById("input").value.trim();
        key = document.getElementById("key").value.trim();

        if (!input || !key) {
          alert("Please enter both text and key.");
          return;
        }

        if (containsLetter(input) || containsLetter(key)) {
          let inputL;
          let keyL;
          if (containsLetter(input)) {
            inputL = getLetters(input);
          }

          if (containsLetter(key)) {
            keyL = getLetters(key);
          }

          // plaintext letter and key match check
          if (containsLetter(input) === false && containsLetter(key)) {
            alert("Provide plaintext in letter(s) to encrypt with given key in letter(s) or remove the key in letter(s) to continue");
            return;
          }

          if (containsLetter(key) == false && containsLetter(input)) {
            alert("Provide key in letter(s) to encrypt plaintext in letter(s) or remove the plaintext in letter(s) to continue");
            return;
          }


          if (select_cipher.value === "alpha") {
            let myPalestineKeyL = getPalestineKey(keyL);
            let myAlphaL = new Vigenere(inputL, myPalestineKeyL);
            encryptedLetters = myAlphaL.getEncryptedLetters();
          } else if (select_cipher.value === "classical_Vigenere") {
            let myVigenereL = new Vigenere(inputL, keyL);
            encryptedLetters = myVigenereL.getEncryptedLetters();
          }

        }// containsLetter()

        if (containsDigit(input) || containsDigit(key)) {
          let inputD;
          let keyD;
          if (containsDigit(input)) {
            inputD = getDigits(input);
          }

          if (containsDigit(key)) {
            keyD = getDigits(key);
          }

          // plaintext digits and key match check
          if (containsDigit(input) === false && containsDigit(key)) {
            alert("Provide plaintext in digit(s) to encrypt with given key in digit(s) or remove the key in digit(s) to continue");
            return;
          }

          if (containsDigit(key) == false && containsDigit(input)) {
            alert("Provide key in digit(s) to encrypt plaintext in digit(s) or remove the plaintext in digit(s) to continue");
            return;
          }



          if (select_cipher.value === "alpha") {
            let myPalestineKeyD = getPalestineKey(keyD);
            let myAlphaD = new Vigenere(inputD, myPalestineKeyD);
            encryptedDigits = myAlphaD.getEncryptedDigits();
          } else if (select_cipher.value === "classical_Vigenere") {
            let myVigenereD = new Vigenere(inputD, keyD);
            encryptedDigits = myVigenereD.getEncryptedDigits();
          }

        }// containsDigit()
        document.getElementById('output').value = format(encryptedLetters, encryptedDigits);
      } // else if (dchecked==false)
      document.getElementById("printKeyBTN").disabled = false;
    } // encrypt()


    // Decryption function

    function decryptText() {

      encryptClick = false;
      decryptClick = true;

      document.getElementById("keyprint").value = "";

      let dchecked = document.getElementById('diffusion_option').checked;
      let impchecked = document.getElementById('implementation_option').checked;

      input = document.getElementById("input").value.trim();
      key = document.getElementById("key").value.trim();
      document.getElementById("key").value = key.toUpperCase();

      if (!input || !key) {
        alert("Please enter both text and key.");
        return;
      }

      if (dchecked == true || impchecked == true) {

        if (containsLetter(input) || containsLetter(key)) {

          let lettersKey = '';
          let myExpandedLettersKey = '';
          if (containsLetter(key)) {
            lettersKey = getLetters(key);
            myExpandedLettersKey = getPalestineKey(lettersKey);
          }

          let lettersCpt = '';

          if (containsLetter(input)) {
            lettersCpt = getLetters(input);

            if (select_cipher.value === 'beta') {
              // Palestine Cipher Decryption: Beta Implementation 
              let myVigenereKeyL = getVigenereKey(lettersKey);
              let myBetaL = new Palestine(lettersCpt, myVigenereKeyL);
              decryptedLetters = myBetaL.getDecryptedLetters();
            } else if (select_cipher.value === 'gamma') {
              // Palestine Cipher Decryption: Gamma Implementation      
              let myPalestineKeyL = getPalestineKey(lettersKey);
              let myGammaL = new Palestine(lettersCpt, myPalestineKeyL);
              decryptedLetters = myGammaL.getDecryptedLetters();
            }

          }

          // ciphertext letter and key match check
          if (containsLetter(input) === false && containsLetter(key)) {
            alert("Provide ciphertext in letter(s) to decrypt with given key in letter(s) or remove the key in letter(s) to continue");
            return;
          }

          if (containsLetter(key) == false && containsLetter(input)) {
            alert("Provide key in letter(s) to decrypt ciphertext in letter(s) or remove the ciphertext in letter(s) to continue");
            return;
          }

          undiffusedLetters = getDiffusedMessage(decryptedLetters);

        } //containsLetter()

        if (containsDigit(input) || containsDigit(key)) {

          let digitsKey = '';
          if (containsDigit(key)) {
            digitsKey = getDigits(key);
          }

          let digitsCpt = '';

          if (containsDigit(input)) {
            digitsCpt = getDigits(input);

            if (select_cipher.value === 'beta') {
              // Palestine Cipher Decryption: Beta Implementation 
              let myVigenereKeyD = getVigenereKey(digitsKey);
              let myBetaD = new Palestine(digitsCpt, myVigenereKeyD);
              decryptedDigits = myBetaD.getDecryptedDigits();
            } else if (select_cipher.value === 'gamma') {
              // Palestine Cipher Decryption: Gamma Implementation      
              let myPalestineKeyD = getPalestineKey(digitsKey);
              let myGammaD = new Palestine(digitsCpt, myPalestineKeyD);
              decryptedDigits = myGammaD.getDecryptedDigits();
            }

          }

          // ciphertext digits and key match check
          if (containsDigit(input) === false && containsDigit(key)) {
            alert("Provide ciphertext in digit(s) to decrypt with given key in digit(s) or remove the key in digit(s) to continue");
            return;
          }

          if (containsDigit(key) == false && containsDigit(input)) {
            alert("Provide key in digit(s) to decrypt ciphertext in digit(s) or remove the ciphertext in digit(s) to continue");
            return;
          }


          undiffusedDigits = getDiffusedMessage(decryptedDigits);
        } // containsDigit();       

        document.getElementById("output").value = format(undiffusedLetters, undiffusedDigits);

      } else if (dchecked == false) {// Vigenère Cipher Decryption

        input = document.getElementById("input").value.trim();
        key = document.getElementById("key").value.trim();

        if (!input || !key) {
          alert("Please enter both text and key.");
          return;
        }

        if (containsLetter(input) || containsLetter(key)) {

          let inputL;
          let keyL;

          if (containsLetter(input)) {
            inputL = getLetters(input);
          }

          if (containsLetter(key)) {
            keyL = getLetters(key);
          }

          // ciphertext letter and key match check
          if (containsLetter(input) === false && containsLetter(key)) {
            alert("Provide ciphertext in letter(s) to decrypt with given key in letter(s) or remove the key in letter(s) to continue");
            return;
          }

          if (containsLetter(key) == false && containsLetter(input)) {
            alert("Provide key in letter(s) to decrypt ciphertext in letter(s) or remove the ciphertext in letter(s) to continue");
            return;
          }

          if (select_cipher.value === "alpha") {
            let myPalestineKeyL = getPalestineKey(keyL);
            let myAlphaL = new Vigenere(inputL, myPalestineKeyL);
            decryptedLetters = myAlphaL.getDecryptedLetters();
          } else if (select_cipher.value === "classical_Vigenere") {
            let myVigenereL = new Vigenere(inputL, keyL);
            decryptedLetters = myVigenereL.getDecryptedLetters();
          }

        } // containsLetter()

        if (containsDigit(input) || containsDigit(key)) {

          let inputD;
          let keyD;

          if (containsDigit(input)) {
            inputD = getDigits(input);
          }

          if (containsDigit(key)) {
            keyD = getDigits(key);
          }

          // ciphertext digits and key match check
          if (containsDigit(input) === false && containsDigit(key)) {
            alert("Provide ciphertext in digit(s) to decrypt with given key in digit(s) or remove the key in digit(s) to continue");
            return;
          }

          if (containsDigit(key) == false && containsDigit(input)) {
            alert("Provide key in digit(s) to decrypt ciphertext in digit(s) or remove the ciphertext in digit(s) to continue");
            return;
          }

          if (select_cipher.value === "alpha") {
            let myPalestineKeyD = getPalestineKey(keyD);
            let myAlphaD = new Vigenere(inputD, myPalestineKeyD);
            decryptedDigits = myAlphaD.getDecryptedDigits();
          } else if (select_cipher.value === "classical_Vigenere") {
            let myVigenereD = new Vigenere(inputD, keyD);
            decryptedDigits = myVigenereL.getDecryptedDigits();
          }
        } // containsDigit()

        document.getElementById('output').value = format(decryptedLetters, decryptedDigits);
      }
      document.getElementById("printKeyBTN").disabled = false;
    } // decrypt()



    function isNEWSFunctionChecked() {
      let checkNEWS = document.getElementById("diffusion_option");
      let result = false;
      if (checkNEWS.checked == true) {
        result = true;
      } else if (checkNEWS.checked == false) {
        result = false;
      }
      return result;
    }

    function isImplementationChecked() {
      let checkImplementation = document.getElementById("implementation_option");
      let result = false;
      if (checkImplementation.checked == true) {
        result = true;
      } else if (checkImplementation.checked == false) {
        result = false;
      }
      return result;
    }

    // get value from select options
    // get diffusion options
    function getNEWSFunction() {
      let myNEWSOptions = document.getElementById('mySelectFunc').options;
      let selectedOption;
      for (let i = 0; i < myNEWSOptions.length; i++) {
        if (myNEWSOptions[i].selected) {
          selectedOption = myNEWSOptions[i].value;
          break;
        }
      }
      return selectedOption;
    }

    // get diffusion options
    function getNEWSImplementation() {
      let myImplementationOptions = document.getElementById('mySelectImplement').options;
      let selectedOption;
      for (let i = 0; i < myImplementationOptions.length; i++) {
        if (myImplementationOptions[i].selected) {
          selectedOption = myImplementationOptions[i].value;
          break;
        }
      }
      return selectedOption;
    }

    function keyDiffuser(myVigenereKey) {
      let key_diff = document.getElementById('key-diffuser-option');
      if (key_diff.value === 'northKey') {
        let north = new NorthDiffusion(myVigenereKey);
        return north.getFirstOrbit();
      } else if (key_diff.value === 'eastKey') {
        let east = new EastDiffusion(myVigenereKey);
        return east.getFirstOrbit();
      } else if (key_diff.value === 'westKey') {
        let west = new WestDiffusion(myVigenereKey);
        return west.getFirstOrbit();
      } else if (key_diff.value === 'southKey') {
        let south = new SouthDiffusion(myVigenereKey);
        return south.getFirstOrbit();
      }
    } // keyDiffuser

    function generatePalestineKey() {

      let key = document.getElementById('genVigKeyInput').value;
      let targetLenL = document.getElementById('keyLenL').value;
      let targetLenD = document.getElementById('keyLenD').value;
      let myPalestineKeyL = "";
      let myPalestineKeyD = "";
      let keyL = "";
      let keyD = "";
      let keyExpandedL = "";
      let keyExpandedD = "";
      //targetLenL=10;
      //targetLenD=10;
      if (key == "") {
        alert("Enter Vigenère key in letters or digits");
        return;
      }

      if (containsLetter(key) || containsDigit(key)) {
        document.getElementById('copy-gen-key').disabled = false;
        if (containsLetter(key)) {
          if (targetLenL < 1) {
            alert("Enter a valid target key length for letters");
            return;
          }
          keyL = getLetters(key);

          keyExpandedL = keyDiffuser(keyL);
          keyL = keyL.toUpperCase();
          while (keyExpandedL.length < targetLenL) {
            //northL = new North(keyExpandedL);
            keyExpandedL = keyExpandedL + keyDiffuser(keyExpandedL);
            keyExpandedL = keyDiffuser(keyExpandedL);
          }

          //northL = new North(keyExpandedL.slice(0, lettersPln.length));

          keyExpandedL = keyDiffuser(keyExpandedL.slice(0, targetLenL));
          myPalestineKeyL = keyExpandedL;
        }

        if (containsDigit(key)) {

          if (targetLenD < 1) {
            alert("Enter a valid target key length for digits");
            return;
          }

          keyD = getDigits(key);

          keyExpandedD = keyDiffuser(keyD);

          while (keyExpandedD.length < targetLenD) {
            //northL = new North(keyExpandedL);
            keyExpandedD = keyExpandedD + keyDiffuser(keyExpandedD);
            keyExpandedD = keyDiffuser(keyExpandedD);
          }
          keyExpandedD = keyDiffuser(keyExpandedD.slice(0, targetLenD));
          myPalestineKeyD = keyExpandedD;
        }

      } // containsLetter(key)||containsDigit(key)
      document.getElementById('genVigKeyInput').value = keyL + " " + keyD;
      document.getElementById('keyPalestineOutput').value = myPalestineKeyL + " " + myPalestineKeyD;
    }

    function getEffectiveKey() {
      // document.getElementById('output').value = "";
      dchecked = document.getElementById('diffusion_option').checked;
      let effectiveKeyL = "";
      let effectiveKeyD = "";
      let key = document.getElementById('key').value;
      let keyL = "";
      let keyD = "";

      if (containsLetter(key)) {
        keyL = getLetters(key).toUpperCase();
      }

      if (containsDigit(key)) {
        keyD = getDigits(key);
      }

      document.getElementById("copy-enc-key").disabled = false;

      let selected_cipher = select_cipher.value;
      if (dchecked == true) {
        if (selected_cipher === "beta") {
          if (keyL != "") {
            effectiveKeyL = getVigenereKey(keyL);
          }
          if (keyD != "") {
            effectiveKeyD = getVigenereKey(keyD);
          }
        } else if (selected_cipher === "gamma") {
          if (keyL != "") {
            effectiveKeyL = getPalestineKey(keyL);
          }
          if (keyD != "") {
            effectiveKeyD = getPalestineKey(keyD);
          }
        }
      } else if (dchecked == false) {
        if (selected_cipher === "alpha") {
          if (keyL != "") {
            effectiveKeyL = getPalestineKey(keyL);
          }
          if (keyD != "") {
            effectiveKeyD = getPalestineKey(keyD);
          }
        } else if (selected_cipher === "classical_Vigenere") {
          if (keyL != "") {
            effectiveKeyL = getVigenereKey(keyL);
          }
          if (keyD != "") {
            effectiveKeyD = getVigenereKey(keyD);
          }
        }
      }
      document.getElementById('keyprint').value = effectiveKeyL + " " + effectiveKeyD;
    }

    function getDiffusedMessage(message) {
      let dchecked = document.getElementById('diffusion_option').checked;
      let impchecked = document.getElementById('implementation_option').checked;

      let result = '';

      if (impchecked == true && dchecked == true) {
        //  alert('N=yes,  I =Yes');

        let selectedImplementation = getNEWSImplementation();
        let selectedNEWSFunction = getNEWSFunction();

        if (selectedImplementation == 'outward') {
          if (selectedNEWSFunction == 'north') {
            result = getOutWardDiffusion(message, 'N');
          } else if (selectedNEWSFunction == 'east') {
            result = getOutWardDiffusion(message, 'E');
          } else if (selectedNEWSFunction == 'west') {
            result = getOutWardDiffusion(message, 'W');
          } else if (selectedNEWSFunction == 'south') {
            result = getOutWardDiffusion(message, 'S');
          } else if (selectedNEWSFunction == 'north_odd') {
            result = getOutWardDiffusion(message, 'NR');
          } else if (selectedNEWSFunction == 'east_odd') {
            result = getOutWardDiffusion(message, 'ER');
          } else if (selectedNEWSFunction == 'west_odd') {
            result = getOutWardDiffusion(message, 'WR');
          } else if (selectedNEWSFunction == 'south_odd') {
            result = getOutWardDiffusion(message, 'SR');
          }

        } else if (selectedImplementation == 'inward') {

          if (selectedNEWSFunction == 'north') {
            result = getInWardDiffusion(message, 'N');
          } else if (selectedNEWSFunction == 'east') {
            result = getInWardDiffusion(message, 'E');
          } else if (selectedNEWSFunction == 'west') {
            result = getInWardDiffusion(message, 'W');
          } else if (selectedNEWSFunction == 'south') {
            result = getInWardDiffusion(message, 'S');
          } else if (selectedNEWSFunction == 'north_odd') {
            result = getInWardDiffusion(message, 'NR');
          } else if (selectedNEWSFunction == 'east_odd') {
            result = getInWardDiffusion(message, 'ER');
          } else if (selectedNEWSFunction == 'west_odd') {
            result = getInWardDiffusion(message, 'WR');
          } else if (selectedNEWSFunction == 'south_odd') {
            result = getInWardDiffusion(message, 'SR');
          }
        } else if (selectedImplementation == 'rightward') {
          if (selectedNEWSFunction == 'north') {
            result = getRightWardDiffusion(message, 'N');
          } else if (selectedNEWSFunction == 'east') {
            result = getRightWardDiffusion(message, 'E');
          } else if (selectedNEWSFunction == 'west') {
            result = getRightWardDiffusion(message, 'W');
          } else if (selectedNEWSFunction == 'south') {
            result = getRightWardDiffusion(message, 'S');
          } else if (selectedNEWSFunction == 'north_odd') {
            result = getRightWardDiffusion(message, 'NR');
          } else if (selectedNEWSFunction == 'east_odd') {
            result = getRightWardDiffusion(message, 'ER');
          } else if (selectedNEWSFunction == 'west_odd') {
            result = getRightWardDiffusion(message, 'WR');
          } else if (selectedNEWSFunction == 'south_odd') {
            result = getRightWardDiffusion(message, 'SR');
          }

        } else if (selectedImplementation == 'rightwardReversed') {
          if (selectedNEWSFunction == 'north') {
            result = getRightWardReversedDiffusion(message, 'N');
          } else if (selectedNEWSFunction == 'east') {
            result = getRightWardReversedDiffusion(message, 'E');
          } else if (selectedNEWSFunction == 'west') {
            result = getRightWardReversedDiffusion(message, 'W');
          } else if (selectedNEWSFunction == 'south') {
            result = getRightWardReversedDiffusion(message, 'S');
          } else if (selectedNEWSFunction == 'north_odd') {
            result = getRightWardReversedDiffusion(message, 'NR');
          } else if (selectedNEWSFunction == 'east_odd') {
            result = getRightWardReversedDiffusion(message, 'ER');
          } else if (selectedNEWSFunction == 'west_odd') {
            result = getRightWardReversedDiffusion(message, 'WR');
          } else if (selectedNEWSFunction == 'south_odd') {
            result = getRightWardReversedDiffusion(message, 'SR');
          }

        } else if (selectedImplementation == 'leftward') {
          if (selectedNEWSFunction == 'north') {
            result = getLeftWardDiffusion(message, 'N');
          } else if (selectedNEWSFunction == 'east') {
            result = getLeftWardDiffusion(message, 'E');
          } else if (selectedNEWSFunction == 'west') {
            result = getLeftWardDiffusion(message, 'W');
          } else if (selectedNEWSFunction == 'south') {
            result = getLeftWardDiffusion(message, 'S');
          } else if (selectedNEWSFunction == 'north_odd') {
            result = getLeftWardDiffusion(message, 'NR');
          } else if (selectedNEWSFunction == 'east_odd') {
            result = getLeftWardDiffusion(message, 'ER');
          } else if (selectedNEWSFunction == 'west_odd') {
            result = getLeftWardDiffusion(message, 'WR');
          } else if (selectedNEWSFunction == 'south_odd') {
            result = getLeftWardDiffusion(message, 'SR');
          }

        } else if (selectedImplementation == 'leftwardReversed') {
          if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'north') {
            result = getLeftWardReversedDiffusion(message, 'N');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'east') {
            result = getLeftWardReversedDiffusion(message, 'E');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'west') {
            result = getLeftWardReversedDiffusion(message, 'W');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'south') {
            result = getLeftWardReversedDiffusion(message, 'S');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'north_odd') {
            result = getLeftWardReversedDiffusion(message, 'NR');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'east_odd') {
            result = getLeftWardReversedDiffusion(message, 'ER');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'west_odd') {
            result = getLeftWardReversedDiffusion(message, 'WR');
          } else if (selectedImplementation == 'leftwardReversed' && selectedNEWSFunction == 'south_odd') {
            result = getLeftWardReversedDiffusion(message, 'SR');
          }

        }

      } else if (impchecked == false && dchecked == true) {
        // alert('N=yes,  I =no');
        let selectedNEWSFunction = getNEWSFunction();
        if (selectedNEWSFunction == 'north') {
          result = getNorthDiffusion(message);
        } else if (selectedNEWSFunction == 'east') {
          result = getEastDiffusion(message);
        } else if (selectedNEWSFunction == 'west') {
          result = getWestDiffusion(message);
        } else if (selectedNEWSFunction == 'south') {
          result = getSouthDiffusion(message);
        } else if (selectedNEWSFunction == 'north_odd') {
          result = getNorthOddDiffusion(message);
        } else if (selectedNEWSFunction == 'east_odd') {
          result = getEastOddDiffusion(message);
        } else if (selectedNEWSFunction == 'west_odd') {
          result = getWestOddDiffusion(message);
        } else if (selectedNEWSFunction == 'south_odd') {
          result = getSouthOddDiffusion(message);
        }
      } // Only NEWS Function Option Selected
      return result;
    } // getDiffusedMessage();



    function newsDiffuseExtract(message, functionDiff, _PI) {

      let diffusedIntermediateChars = '';
      if (functionDiff.toUpperCase() == 'N') {
        diffusedIntermediateChars = getNorthDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'E') {
        diffusedIntermediateChars = getEastDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'W') {
        diffusedIntermediateChars = getWestDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'S') {
        diffusedIntermediateChars = getSouthDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'NR') {
        diffusedIntermediateChars = getNorthOddDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'ER') {
        diffusedIntermediateChars = getEastOddDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'WR') {
        diffusedIntermediateChars = getWestOddDiffusion(message, _PI);
      } else if (functionDiff.toUpperCase() == 'SR') {
        diffusedIntermediateChars = getSouthOddDiffusion(message, _PI);
      } else {
        alert('Wrong diffusion option');
        return;
      }
      return diffusedIntermediateChars;
    }


    // diffusion functions
    function getNorthDiffusion(message) {
      initIndexVariables(message);
      let north = new NorthDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return north.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return north.getOrbitAt(1);
      }
    }

    function getEastDiffusion(message) {
      initIndexVariables(message);
      let east = new EastDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return east.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return east.getOrbitAt(1);
      }
    }

    function getWestDiffusion(message) {
      initIndexVariables(message);
      let west = new WestDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return west.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return west.getOrbitAt(1);
      }
    }

    function getSouthDiffusion(message) {
      initIndexVariables(message);
      let south = new SouthDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return south.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return south.getOrbitAt(1);
      }
    }

    function getNorthOddDiffusion(message) {
      initIndexVariables(message);
      let northR = new NorthOddDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return northR.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return northR.getOrbitAt(1);
      }
    }

    function getEastOddDiffusion(message) {
      initIndexVariables(message);
      let eastR = new EastOddDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return eastR.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return eastR.getOrbitAt(1);
      }
    }

    function getWestOddDiffusion(message) {
      initIndexVariables(message);
      let westR = new WestOddDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return westR.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return westR.getOrbitAt(1);
      }
    }

    function getSouthOddDiffusion(message) {
      initIndexVariables(message);
      let southR = new SouthOddDiffusion(message, _PalestineIndex);
      if (implementationOption.checked === false) {
        return southR.getOrbitAt(orbitIndex);
      } else if (implementationOption.checked === true) {
        return southR.getOrbitAt(1);
      }
    }

    // get implementation diffusion

    function getOutWardDiffusion(message, _NEWSFunction) {

      initIndexVariables(message);
      let outWardDiff = new OutWardDiffusion(message, _NEWSFunction, _PalestineIndex);

      return outWardDiff.getOrbitAt(orbitIndex);
    }

    function getInWardDiffusion(message, _NEWSFunction) {

      initIndexVariables(message);
      let inWardDiff = new InWardDiffusion(message, _NEWSFunction, _PalestineIndex);

      return inWardDiff.getOrbitAt(orbitIndex);
    }

    function getRightWardDiffusion(message, _NEWSFunction) {

      initIndexVariables(message);
      let rightWardDiff = new RightWardDiffusion(message, _NEWSFunction, _PalestineIndex);

      return rightWardDiff.getOrbitAt(orbitIndex);
    }

    function getRightWardReversedDiffusion(message, _NEWSFunction) {

      initIndexVariables(message);
      let rightWardReversedDiff = new RightWardReversedDiffusion(message, _NEWSFunction, _PalestineIndex);

      return rightWardReversedDiff.getOrbitAt(orbitIndex);
    }

    function getLeftWardDiffusion(message, _NEWSFunction) {

      initIndexVariables(message);
      let leftWardDiff = new LeftWardDiffusion(message, _NEWSFunction, _PalestineIndex);

      return leftWardDiff.getOrbitAt(orbitIndex);
    }

    function getLeftWardReversedDiffusion(message, _NEWSFunction) {

      initIndexVariables(message);
      let leftWardReversedDiff = new LeftWardReversedDiffusion(message, _NEWSFunction, _PalestineIndex);

      return leftWardReversedDiff.getOrbitAt(orbitIndex);
    }

    //**********************************************
    function initIndexVariables(message) {
      if (isLetter(message[0])) {
        orbitIndex = document.getElementById('orbitIndexL').value;
        _PalestineIndex = document.getElementById('_PalestineIndexL').value;
      } else if (isDigit(message[0])) {
        orbitIndex = document.getElementById('orbitIndexD').value;
        _PalestineIndex = document.getElementById('_PalestineIndexD').value;
      }
    }// initIndexVariables()


    // let functionDiff;
    function checkDiffusionOption() {
      if (!(functionDiff == "N" || functionDiff == "NR" || functionDiff == "E" || functionDiff == "ER" || functionDiff == "W" || functionDiff == "WR" || functionDiff == "S" || functionDiff == "SR")) {
        alert("enter valid diffusion option");
        return;
      }
    }

    function getPalestineKey(key) {
      let input = document.getElementById("input").value.trim();
      // let key = document.getElementById("key").value.trim();

      if (!input || !key) {
        alert("Please enter both text and key.");
        return;
      }

      let generatedLettersKey = '';
      let generatedDigitsKey = '';
      let generatedKey = '';

      if (containsLetter(key) && containsLetter(input)) {
        // for letters
        let lettersPln = '';
        let lettersKey = '';
        let keyExpandedL = '';

        lettersKey = getLetters(key);
        lettersPln = getLetters(input);
        keyExpandedL = keyDiffuser(lettersKey);

        while (keyExpandedL.length < lettersPln.length) {
          //northL = new North(keyExpandedL);
          keyExpandedL = keyExpandedL + keyDiffuser(keyExpandedL);
          keyExpandedL = keyDiffuser(keyExpandedL);
        }

        //northL = new North(keyExpandedL.slice(0, lettersPln.length));
        generatedLettersKey = keyDiffuser(keyExpandedL.slice(0, lettersPln.length));
        generatedKey = generatedLettersKey;

      } else if (containsDigit(key) && containsDigit(input)) {

        // for digits
        let digitsPln = '';
        let digitsKey = '';
        let keyExpandedD = '';

        digitsKey = getDigits(key);
        digitsPln = getDigits(input);
        //northD = new North(key);
        keyExpandedD = keyDiffuser(digitsKey);

        while (keyExpandedD.length < digitsPln.length) {
          //northD = new North(keyExpandedD);
          keyExpandedD = keyExpandedD + keyDiffuser(keyExpandedD);
          keyExpandedD = keyDiffuser(keyExpandedD);
        }

        // northD = new North(keyExpandedD.slice(0, digitsPln.length));
        generatedDigitsKey = keyDiffuser(keyExpandedD.slice(0, digitsPln.length));
        generatedKey = generatedDigitsKey;

      } // else if sttmnt

      return generatedKey;
    }

    function getVigenereKey(key) {
      input = document.getElementById("input").value.trim();

      let plainMessage = '';
      let keyRepeated = '';

      if (containsLetter(input) && containsLetter(key)) {
        plainMessage = getLetters(input);

        let myVigenere = new Vigenere(plainMessage, key);
        keyRepeated = myVigenere.getRepeatedKey().toUpperCase();

      }

      if (containsDigit(input) && containsDigit(key)) {
        plainMessage = getDigits(input);

        let myVigenere = new Vigenere(plainMessage, key);
        keyRepeated = myVigenere.getRepeatedKey();
      }
      return keyRepeated;
    }


    // send collected letters or digits
    function showGeneratedKey() {
      key = document.getElementById("key").value.trim();
      dchecked = document.getElementById('diffusion_option').checked;

      if (!input || !key) {
        alert("Please enter both text and key.");
        return;
      }

      let lettersKey = "";
      let digitsKey = "";

      if (dchecked == true) {

        if (containsLetter(key)) {
          let keyL = getLetters(key);
          if (select_cipher.value === "beta") {
            lettersKey = getVigenereKey(keyL)
          } else if (select_cipher.value === "gamma") {
            lettersKey = getPalestineKey(keyL);
          }
        }

        if (containsDigit(key)) {
          let keyD = getDigits(key);
          if (select_cipher.value === "beta") {
            digitsKey = getVigenereKey(keyD)
          } else if (select_cipher.value === "gamma") {
            digitsKey = getPalestineKey(keyD);
          }
        }
        alert(lettersKey + ' ' + digitsKey);

      } else if (dchecked == false) {
        let lettersKey = "";
        let digitsKey = "";
        if (containsLetter(key)) {
          let keyL = getLetters(key);
          if (select_cipher.value === "alpha") {
            lettersKey = getPalestineKey(keyL)
          } else if (select_cipher.value === "classical_Vigenere") {
            lettersKey = getVigenereKey(keyL);
          }
        }
        if (containsDigit(key)) {
          let keyD = getDigits(key);
          if (select_cipher.value === "alpha") {
            digitsKey = getPalestineKey(keyD)
          } else if (select_cipher.value === "classical_Vigenere") {
            digitsKey = getVigenereKey(keyD);
          }
        }

        alert(lettersKey + " " + digitsKey);
      }
    }

    function clearGenField() {
      let keyPal = document.getElementById("keyPalestineOutput").value = "";
      let vigKey = document.getElementById("genVigKeyInput").value = "";
      let keyLenL = document.getElementById("keyLenL").value = "";
      let keyLenD = document.getElementById("keyLenD").value = "";
      if (keyPal !== "" || vigKey != "" || keyLenL != "" || keyLenD != "") {
        document.getElementById("keyPalestineOutput").value = "";
        document.getElementById("genVigKeyInput").value = "";
        document.getElementById("keyLenL").value = "";
        document.getElementById("keyLenD").value = "";
      }
      document.getElementById('copy-gen-key').disabled = true;

    }

    function containsLetter(text) {
      let result = false;
      for (let i = 0; i < text.length; i++) {
        if (isLetter(text[i])) {
          result = true;
          break;
        }
      }
      return result;
    }

    function containsDigit(text) {
      let result = false;
      for (let i = 0; i < text.length; i++) {
        if (isDigit(text[i])) {
          result = true;
          break;
        }
      }
      return result;
    }

    // Extract letters from input
    function getLetters(myLetters) {

      let extractedLetters = "";

      if (!myLetters) {
        alert("Please provide a text.");
        return;
      }

      for (let i = 0; i < myLetters.length; i++) {

        if (this.isLetter(myLetters[i])) {
          extractedLetters += myLetters[i];
        } else {
          continue;
        }
      }

      return extractedLetters;
    }

    // Checks if given character is a letter
    function isLetter(myChar) {
      myChar = myChar.toUpperCase();
      let result = false;
      if (myChar.charCodeAt(0) >= 65 && myChar.charCodeAt(0) <= 91) {
        result = true;
      }
      return result;
    }

    // Extract digits from input
    function getDigits(myDigit) {
      let extractedPlainDigits = "";

      if (!myDigit) {
        alert("Please enter both text and key.");
        return;
      }

      for (let i = 0; i < myDigit.length; i++) {

        if (this.isDigit(myDigit[i])) {
          extractedPlainDigits += myDigit[i];
        } else {
          continue;
        }
      }

      return extractedPlainDigits;
    }

    function isDigit(myChar) {
      let result = false;
      if (myChar.charCodeAt(0) >= 48 && myChar.charCodeAt(0) <= 57) {
        result = true;
      }
      return result;

    }

    function showDiffusion() {
      let func_implement_cont = document.getElementById("func_implement_container");
      func_implement_cont.style.visibility = "visible";
      func_implement_cont.style.height = "";
    }

    function hideDiffusion() {
      let func_implement_cont = document.getElementById("func_implement_container");
      func_implement_cont.style.visibility = "hidden";
      func_implement_cont.style.height = 0;
    }

    function showIndexesL() {
      document.getElementsByClassName("indexes")[0].style.visibility = "visible";
      document.getElementsByClassName("indexes")[0].style.height = "";
      document.getElementById("_OILcontainer").style.visibility = "visible";
      document.getElementById("_PILcontainer").style.visibility = "visible";

    }

    function hideIndexesL() {
      document.getElementsByClassName("indexes")[0].style.visibility = "hidden";
      document.getElementsByClassName("indexes")[0].style.height = 0;
      document.getElementById("_OILcontainer").style.visibility = "hidden";
      document.getElementById("_PILcontainer").style.visibility = "hidden";
    }

    function showIndexesD() {
      document.getElementsByClassName("indexes")[1].style.visibility = "visible";
      document.getElementsByClassName("indexes")[1].style.height = "";
      document.getElementById("_OIDcontainer").style.visibility = "visible";
      document.getElementById("_PIDcontainer").style.visibility = "visible";

    }

    function hideIndexesD() {
      document.getElementById("_OIDcontainer").style.visibility = "hidden";
      document.getElementById("_PIDcontainer").style.visibility = "hidden";
      document.getElementsByClassName("indexes")[1].style.visibility = "hidden";
      document.getElementsByClassName("indexes")[1].style.height = 0;

    }


    function reseter() {
      hideIndexesL();
      hideIndexesD();
      document.getElementById("input").value = "";
      document.getElementById("key").value = "";
      document.getElementById("output").value = "";
      document.getElementById("keyprint").value = "";
      document.getElementById("orbitIndexL").value = 1;
      document.getElementById("orbitIndexD").value = 1;
      document.getElementById("_PalestineIndexL").value = 0;
      document.getElementById("_PalestineIndexD").value = 0;
      document.getElementById("mySelectImplement").selectedIndex = 0;
      document.getElementById("mySelectFunc").selectedIndex = 0;
      document.getElementById("encRadio").checked = true;
      document.getElementById('implementation_option').checked = false;
      document.getElementById("mySelectImplement").disabled = true;
      document.getElementById("btnEnc").disabled = false;
      document.getElementById("btnDec").disabled = true;
      document.getElementById("lettersLen").innerText = "Letters length = 0, ";
      document.getElementById("digitsLen").innerText = "Digits length = 0";
      document.getElementById("copy-enc-key").disabled = true;
      document.getElementById("copy-output").disabled = true;

    }

    function format(encryptedLetters, encryptedDigits) {

      const input = document.getElementById("input").value.trim();

      let letterCount = 0;
      let digitCount = 0;

      let myFormatArray = new Array();

      for (let i = 0; i < input.length; i++) {
        if (formatState == true) {
          if (isLetter(input[i]) || isDigit(input[i])) {
            if (isLetter(input[i])) {
              if (input[i] === input[i].toUpperCase()) {
                myFormatArray.push(encryptedLetters[letterCount].toUpperCase());
                letterCount++;
              } else {
                myFormatArray.push(encryptedLetters[letterCount].toLowerCase());
                letterCount++;
              }
            } else if (isDigit(input[i])) {
              myFormatArray.push(encryptedDigits[digitCount]);
              digitCount++;
            }

          } else {
            myFormatArray.push(input[i]); // Non-alphabetic or non-digits characters remain unchanged
          }
          /*formatState*/
        } else if (formatState == false) {
          if (isLetter(input[i]) || isDigit(input[i])) {

            if (isLetter(input[i])) {
              myFormatArray.push(encryptedLetters[letterCount]);
              letterCount++;
            } else if (isDigit(input[i])) {
              myFormatArray.push(encryptedDigits[digitCount]);
              digitCount++;
            }

          } else {
            myFormatArray.push(""); // remove white space
          }
        }// myFormat==false
      }// for loop

      return myFormatArray.join("");
    }// format()



  </script>
  <!-- NEWS diffusion implementations scripts -->
  <script src="scripts/news_implementations/outWardDiffusion.js"></script>
  <script src="scripts/news_implementations/inWardDiffusion.js"></script>
  <script src="scripts/news_implementations/rightWardDiffusion.js"></script>
  <script src="scripts/news_implementations/rightWardReversedDiffusion.js"></script>
  <script src="scripts/news_implementations/leftWardDiffusion.js"></script>
  <script src="scripts/news_implementations/leftWardReversedDiffusion.js"></script>

</body>

</html>